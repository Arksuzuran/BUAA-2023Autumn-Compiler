# BUAA-2023Autume-Compiler
这是**北航2023年秋 编译课程的实验课程作业代码**

**迭代过程详见各分支，final分支为最终版代码**

源程序语言是课程组要求的SysY，中间代码为LLVM，目标代码为mips

中端实现了Mem2Reg优化，后端使用了图着色寄存器分配，最终竞速排名17

### 1.一些建议

请务必认真学习理论课程。认真听讲，认真完成课下作业，每周进行预习，考前一定要刷完所有你能够获取的往年题。

对于理论课程的小测，请务必结合上届题目，提前做题。小测可以和同学进行合作答题，老师是默许的。

对于实验课的编译器，请务必多找前届代码，参考越多，坐牢越少，竞速越快。即使您是佬，也尽量多进行参考，能节约不少宝贵的时间，用于其他课程的学习。

编译是最耗时的课程之一，每一次实验迭代的题目都会占用我两周左右的时间，请务必为编译预留足够的学习时间。请尽早开始代码编写，尽量做到每次作业发布当天就开始。

### 2.实验期末考试

强烈建议在期末考前做一遍前两年期末考题，仅仅熟悉代码或许是不够的，尤其是对于平常借鉴较多的同学。因为期末考试需要你在短短的2h内实现一些挑战性的文法。

题干里一般会给出一些提示，请务必重视。

#### 2.1 考试题型

##### 新文法题(10)

一般是新加两条文法，部分测试点只涉及第一个文法，部分测试点只涉及第二个文法，其余测试点涉及所有文法。第二个文法一般来说具有一些难度。

##### 竞速题(10)

不涉及新文法，直接提交课下代码即可。**白送分**。

##### 其他的题

比如关于你自己代码设计的简答题等。**白送分**。

例如“对于如下代码，描述你的寄存器是如何进行运算优化的。如果你没有进行运算优化，请你结合理论知识简述一下可能采取的优化策略”。

#### 2.2 2023年期末考试

##### 题目

期末考试题目为增加两条文法：

- ` ForStmt → BType Ident '=' InitVal`.

  即在**for循环头处声明并初始化变量**的效果，例如`for(int i = 1;;)`。这里声明的变量作用域应当为这个for循环。

- `MulExp → MulExp ('*' | '/' | '%' | '**') UnaryExp`。

  我们把`MulExp`记为`a`，把`UnaryExp`记为`b`，则有规定：

  - 算符`**`的效果是`(a+b)**b`
  - 保证`b`一定是常数

##### 分析

本次期末考试难度适中。

建议尝试移除"保证`b`一定是常数"这一条件，再进行解题，挑战一下。

对于第一条文法，请注意新声明的变量的作用域（例如建立符号表的时机，新符号加入符号表的时机）。

对于第二条文法，题目里b是常量，直接在编译器里取出来常量`b`的值，生成b条乘法中间代码即可。如果b不是常量，可以考虑手动生成一个for循环，结合对于` 'for' '(' [ForStmt] ';' [Cond] ';' [forStmt] ')' Stmt`翻译为中间代码的实现，略加修改即可。

#### 2.3 2022年期末考试

相对来说比较友好的题目。

- 新增文法：

  - VarDef → Ident `=` `getint``(``)`

- 修改文法：**按位与 `bitand`**

  - MulExp → UnaryExp | MulExp (`*`|`/`|`%`| **`bitand`** ) UnaryExp

- 说明：

  - 变量定义时，**只可能** 是一个普通int变量定义，不会出现数组变量赋值，如`int a[10] = getint();`这种情况。
  - 按位与的运算符号 **&** 被替换为了关键字 **bitand** 。**特别注意**其运算优先级与 **乘除模** 同级，与C/Java 不同。例如 **a + b bitand c \* d** 的中间代码为

  ```
  t1 = b bitand c
  t2 = t1 * d
  t3 = a + t2
  ```

  - **常量表达式 `ConstExp`** 的计算中不会出现按位与运算，例如 **const int p = N bitand M** 和 **int a[N bitand M]** （其中M和N为常量）这些是不合法的。
  - 新增语法规则中，bitand为**保留关键字**，即测试样例不会出现 **ident为bitand** 的情况。
  - **int i=getint();** 等价于 **int i; 与 i=getint();** 两条语句。
  - **a bitand b** 运算效果等价于C/Java中的 **a & b** 。
  - 提示：按位与运算可以用 **`and`** 指令实现，其格式与 **`add`** 等指令相同。

- 测试样例

```
int main()
{
	int i = getint(), j = getint();
	printf("%d", i bitand j);
	return 0;
}
```

- 样例输入

```
5
9
```

- 样例输出

```
1
```

- 样例说明

```
// i = 5(00000101), j = 9(00001001)
// 按位与结果为 1(00000001)
```

- 评分标准
  - C级样例
    - testfile1-3 不涉及新增文法
    - testfile4-5 仅增加了形如 **int i=getint();** 内容
    - testfile6-7 仅增加了**bitand**内容
  - B级样例
    - testfile8 不涉及新增文法
    - testfile9 仅增加形如 **int i=getint();** 内容
    - testfile10 仅增加了**bitand**内容
    - testfile11 增加全部两项内容
  - A级样例
    - testfile12 不涉及新增文法
    - testfile13 仅增加形如 **int i=getint();** 内容
    - testfile14 仅增加了**bitand**内容
    - testfile15 增加全部两项内容

![9313FA80078F84419D52305409655FD7](https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/9313FA80078F84419D52305409655FD7.png)
