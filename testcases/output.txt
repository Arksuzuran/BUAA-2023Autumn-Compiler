CONSTTK const
INTTK int
IDENFR const_var1
ASSIGN =
INTCON 2
PLUS +
PLUS +
MINU -
PLUS +
MINU -
PLUS +
INTCON 1
COMMA ,
IDENFR const_arr1
LBRACK [
INTCON 3
RBRACK ]
ASSIGN =
LBRACE {
INTCON 1
COMMA ,
INTCON 2
COMMA ,
INTCON 3
RBRACE }
COMMA ,
IDENFR const_arr2
LBRACK [
INTCON 1
PLUS +
INTCON 1
RBRACK ]
LBRACK [
INTCON 2
RBRACK ]
ASSIGN =
LBRACE {
LBRACE {
INTCON 1
COMMA ,
INTCON 2
RBRACE }
COMMA ,
LBRACE {
INTCON 3
COMMA ,
INTCON 4
RBRACE }
RBRACE }
SEMICN ;
INTTK int
IDENFR var1
ASSIGN =
INTCON 1
MULT *
INTCON 2
COMMA ,
IDENFR arr1
LBRACK [
INTCON 2
RBRACK ]
ASSIGN =
LBRACE {
INTCON 3
MOD %
INTCON 2
COMMA ,
INTCON 4
DIV /
INTCON 2
RBRACE }
COMMA ,
IDENFR arr2
LBRACK [
INTCON 3
MINU -
INTCON 1
RBRACK ]
LBRACK [
INTCON 2
MULT *
INTCON 1
RBRACK ]
ASSIGN =
LBRACE {
LBRACE {
INTCON 1
COMMA ,
INTCON 2
RBRACE }
COMMA ,
LBRACE {
INTCON 3
COMMA ,
INTCON 4
RBRACE }
RBRACE }
COMMA ,
IDENFR arr3
LBRACK [
INTCON 6
RBRACK ]
LBRACK [
INTCON 3
RBRACK ]
SEMICN ;
VOIDTK void
IDENFR fun1
LPARENT (
RPARENT )
LBRACE {
LPARENT (
LPARENT (
INTCON 1
PLUS +
INTCON 0
RPARENT )
RPARENT )
SEMICN ;
LBRACE {
RBRACE }
LBRACE {
LBRACE {
LBRACE {
LBRACE {
LBRACE {
LBRACE {
LBRACE {
LBRACE {
SEMICN ;
RBRACE }
LPARENT (
INTCON 24100
RPARENT )
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
RBRACE }
RBRACE }
RBRACE }
RBRACE }
INTTK int
IDENFR var1
ASSIGN =
INTCON 1190
SEMICN ;
LBRACE {
INTTK int
IDENFR var1
ASSIGN =
INTCON 11900
SEMICN ;
RBRACE }
IFTK if
LPARENT (
IDENFR var1
EQL ==
INTCON 1190
RPARENT )
PRINTFTK printf
LPARENT (
STRCON "pass: local && global var test\n"
RPARENT )
SEMICN ;
ELSETK else
PRINTFTK printf
LPARENT (
STRCON "failed: local && global var test\n"
RPARENT )
SEMICN ;
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
IDENFR fun2
LPARENT (
RPARENT )
LBRACE {
LBRACE {
SEMICN ;
RBRACE }
INTTK int
IDENFR sum
ASSIGN =
INTCON 0
COMMA ,
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
INTCON 1190
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR i
GEQ >=
INTCON 5
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
IFTK if
LPARENT (
IDENFR i
GEQ >=
INTCON 4
RPARENT )
LBRACE {
CONTINUETK continue
SEMICN ;
RBRACE }
IDENFR sum
ASSIGN =
IDENFR sum
PLUS +
IDENFR i
SEMICN ;
RBRACE }
FORTK for
LPARENT (
SEMICN ;
SEMICN ;
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
SEMICN ;
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
FORTK for
LPARENT (
SEMICN ;
IDENFR i
LSS <
INTCON 0
SEMICN ;
RPARENT )
LBRACE {
RBRACE }
FORTK for
LPARENT (
SEMICN ;
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
INTCON 0
SEMICN ;
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
FORTK for
LPARENT (
SEMICN ;
IDENFR i
LSS <
INTCON 0
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
IFTK if
LPARENT (
NOT !
INTCON 1
OR ||
IDENFR sum
EQL ==
INTCON 13
DIV /
INTCON 2
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR sum
NEQ !=
PLUS +
MINU -
PLUS +
INTCON 1
PLUS +
INTCON 6
RPARENT )
IFTK if
LPARENT (
IDENFR sum
GRE >
INTCON 5
RPARENT )
IFTK if
LPARENT (
IDENFR sum
GEQ >=
INTCON 5
RPARENT )
IFTK if
LPARENT (
IDENFR sum
LSS <
INTCON 7
RPARENT )
IFTK if
LPARENT (
IDENFR sum
LEQ <=
INTCON 7
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "pass: loop && cond test\n"
RPARENT )
SEMICN ;
RETURNTK return
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "failed: loop && cond test\n"
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
INTTK int
IDENFR fun3
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR a
GRE >
IDENFR b
RPARENT )
RETURNTK return
IDENFR a
SEMICN ;
RETURNTK return
IDENFR b
SEMICN ;
RBRACE }
INTTK int
IDENFR fun4
LPARENT (
INTTK int
IDENFR a
RPARENT )
LBRACE {
INTTK int
IDENFR n
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "please input an int between 1 and 10(border included):\n"
RPARENT )
SEMICN ;
IDENFR n
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR n
GEQ >=
INTCON 1
AND &&
IDENFR n
LEQ <=
INTCON 10
RPARENT )
LBRACE {
INTTK int
IDENFR tmp1
ASSIGN =
IDENFR a
MINU -
INTCON 0
MULT *
INTCON 2
SEMICN ;
INTTK int
IDENFR tmp2
ASSIGN =
INTCON 3
SEMICN ;
IDENFR tmp1
ASSIGN =
IDENFR tmp1
PLUS +
IDENFR tmp2
MINU -
IDENFR fun3
LPARENT (
IDENFR fun3
LPARENT (
IDENFR fun3
LPARENT (
IDENFR tmp1
COMMA ,
INTCON 0
RPARENT )
COMMA ,
INTCON 0
RPARENT )
COMMA ,
IDENFR fun3
LPARENT (
IDENFR tmp2
COMMA ,
INTCON 0
RPARENT )
RPARENT )
SEMICN ;
IDENFR tmp2
ASSIGN =
IDENFR fun3
LPARENT (
IDENFR fun3
LPARENT (
IDENFR tmp1
COMMA ,
MINU -
INTCON 2
RPARENT )
COMMA ,
IDENFR fun3
LPARENT (
IDENFR tmp2
COMMA ,
INTCON 65959
MOD %
INTCON 2
RPARENT )
RPARENT )
SEMICN ;
INTTK int
IDENFR tmp3
ASSIGN =
LPARENT (
IDENFR tmp1
PLUS +
LPARENT (
LPARENT (
IDENFR tmp2
MOD %
IDENFR tmp1
RPARENT )
RPARENT )
MINU -
INTCON 2
MULT *
IDENFR tmp1
DIV /
IDENFR tmp2
RPARENT )
MULT *
INTCON 3
DIV /
INTCON 5
SEMICN ;
IFTK if
LPARENT (
IDENFR tmp3
MULT *
IDENFR n
EQL ==
IDENFR n
MOD %
LPARENT (
INTCON 10
MULT *
IDENFR tmp3
RPARENT )
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "pass: AddExp test. input: %d. input*2: %d.\n"
COMMA ,
IDENFR n
COMMA ,
IDENFR n
MULT *
INTCON 2
RPARENT )
SEMICN ;
RETURNTK return
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "failed: AddExp test\n"
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
VOIDTK void
IDENFR fun5
LPARENT (
INTTK int
IDENFR a1
COMMA ,
INTTK int
IDENFR a2
COMMA ,
INTTK int
IDENFR b
LBRACK [
RBRACK ]
COMMA ,
INTTK int
IDENFR c
LBRACK [
RBRACK ]
LBRACK [
INTCON 3
MINU -
INTCON 1
RBRACK ]
COMMA ,
INTTK int
IDENFR d
LBRACK [
RBRACK ]
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR a1
EQL ==
MINU -
INTCON 2
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR a2
EQL ==
INTCON 2
RPARENT )
LBRACE {
INTTK int
IDENFR i
COMMA ,
IDENFR j
ASSIGN =
INTCON 0
COMMA ,
IDENFR flag
ASSIGN =
INTCON 1
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
IDENFR const_var1
MINU -
INTCON 1
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR b
LBRACK [
IDENFR i
RBRACK ]
NEQ !=
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IDENFR flag
ASSIGN =
INTCON 0
SEMICN ;
BREAKTK break
SEMICN ;
RBRACE }
RBRACE }
IFTK if
LPARENT (
IDENFR flag
RPARENT )
LBRACE {
IDENFR flag
ASSIGN =
INTCON 1
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
INTCON 2
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR c
LBRACK [
INTCON 1
RBRACK ]
LBRACK [
IDENFR i
RBRACK ]
NEQ !=
IDENFR d
LBRACK [
IDENFR i
RBRACK ]
RPARENT )
LBRACE {
IDENFR flag
ASSIGN =
INTCON 0
SEMICN ;
BREAKTK break
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
IFTK if
LPARENT (
IDENFR flag
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "pass: (B) Array test\n"
RPARENT )
SEMICN ;
RETURNTK return
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "failed: (B) Array test\n"
RPARENT )
SEMICN ;
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
IDENFR fun7
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
LBRACK [
RBRACK ]
COMMA ,
INTTK int
IDENFR c
LBRACK [
RBRACK ]
LBRACK [
INTCON 1
PLUS +
INTCON 1
RBRACK ]
COMMA ,
INTTK int
IDENFR d
LBRACK [
RBRACK ]
RPARENT )
LBRACE {
INTTK int
IDENFR e
LBRACK [
INTCON 1
RBRACK ]
LBRACK [
INTCON 1
RBRACK ]
ASSIGN =
LBRACE {
LBRACE {
INTCON 1
RBRACE }
RBRACE }
SEMICN ;
INTTK int
IDENFR tmp
ASSIGN =
INTCON 2
SEMICN ;
LBRACE {
INTTK int
IDENFR tmp
ASSIGN =
LPARENT (
INTCON 2
MINU -
INTCON 3
DIV /
INTCON 2
RPARENT )
SEMICN ;
IDENFR tmp
ASSIGN =
IDENFR tmp
MULT *
INTCON 14500
SEMICN ;
LPARENT (
LPARENT (
LPARENT (
LPARENT (
LPARENT (
LPARENT (
IDENFR tmp
MULT *
INTCON 11900
RPARENT )
RPARENT )
RPARENT )
RPARENT )
RPARENT )
RPARENT )
SEMICN ;
RBRACE }
IFTK if
LPARENT (
IDENFR tmp
EQL ==
INTCON 2
RPARENT )
IFTK if
LPARENT (
IDENFR a
EQL ==
IDENFR var1
MOD %
LPARENT (
INTCON 3
PLUS +
INTCON 4
MULT *
INTCON 1
MINU -
INTCON 1
MULT *
INTCON 2
RPARENT )
RPARENT )
IFTK if
LPARENT (
NOT !
IDENFR b
LBRACK [
INTCON 1
RBRACK ]
OR ||
IDENFR b
LBRACK [
INTCON 0
RBRACK ]
NEQ !=
IDENFR arr1
LBRACK [
INTCON 0
RBRACK ]
PLUS +
INTCON 1
AND &&
IDENFR b
LBRACK [
INTCON 0
RBRACK ]
NEQ !=
IDENFR arr1
LBRACK [
INTCON 0
RBRACK ]
MINU -
INTCON 1
RPARENT )
IFTK if
LPARENT (
IDENFR d
LBRACK [
INTCON 0
RBRACK ]
LSS <
IDENFR c
LBRACK [
INTCON 0
RBRACK ]
LBRACK [
INTCON 1
RBRACK ]
AND &&
IDENFR c
LBRACK [
INTCON 0
RBRACK ]
LBRACK [
INTCON 0
RBRACK ]
PLUS +
INTCON 1
LEQ <=
IDENFR d
LBRACK [
INTCON 1
RBRACK ]
RPARENT )
IFTK if
LPARENT (
IDENFR d
LBRACK [
INTCON 1
RBRACK ]
GRE >
IDENFR c
LBRACK [
INTCON 0
RBRACK ]
LBRACK [
INTCON 0
RBRACK ]
AND &&
IDENFR c
LBRACK [
INTCON 0
RBRACK ]
LBRACK [
INTCON 0
RBRACK ]
PLUS +
INTCON 1
GEQ >=
IDENFR d
LBRACK [
INTCON 1
RBRACK ]
RPARENT )
IFTK if
LPARENT (
IDENFR c
LBRACK [
INTCON 1
RBRACK ]
LBRACK [
INTCON 0
RBRACK ]
GRE >
IDENFR c
LBRACK [
INTCON 1
RBRACK ]
LBRACK [
INTCON 1
RBRACK ]
OR ||
NOT !
INTCON 1
RPARENT )
LBRACE {
RBRACE }
ELSETK else
LBRACE {
IFTK if
LPARENT (
NOT !
IDENFR e
LBRACK [
INTCON 0
RBRACK ]
LBRACK [
INTCON 0
RBRACK ]
OR ||
IDENFR c
LBRACK [
INTCON 1
RBRACK ]
LBRACK [
INTCON 1
RBRACK ]
GEQ >=
IDENFR d
LBRACK [
INTCON 0
RBRACK ]
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "pass: (A) Exp test\n"
RPARENT )
SEMICN ;
RETURNTK return
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "failed: (A) Exp test\n"
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "20375331\n"
RPARENT )
SEMICN ;
IDENFR fun1
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR result1
ASSIGN =
IDENFR fun2
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR result2
ASSIGN =
INTCON 3
MULT *
IDENFR fun4
LPARENT (
INTCON 2
MULT *
IDENFR result1
RPARENT )
MINU -
INTCON 1
SEMICN ;
IDENFR fun5
LPARENT (
MINU -
IDENFR result2
COMMA ,
INTCON 2
MULT *
INTCON 7
DIV /
INTCON 5
MOD %
INTCON 3
COMMA ,
IDENFR arr1
COMMA ,
IDENFR arr2
COMMA ,
IDENFR arr2
LBRACK [
INTCON 1
RBRACK ]
RPARENT )
SEMICN ;
IDENFR fun7
LPARENT (
IDENFR var1
COMMA ,
IDENFR arr1
COMMA ,
IDENFR arr2
COMMA ,
IDENFR arr2
LBRACK [
INTCON 0
RBRACK ]
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "Test ends %d"
COMMA ,
INTCON 1
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
